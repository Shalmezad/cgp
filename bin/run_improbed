#!/usr/bin/env python3

import logging
import sys

from cgp.improbed import Brain, BrainBuilder, BrainMutator, Config
from cgp.problems import IrisProblem, GlassProblem, ProblemBase


root = logging.getLogger()
root.setLevel(logging.DEBUG)

handler = logging.StreamHandler(sys.stdout)
handler.setLevel(logging.DEBUG)
formatter = logging.Formatter(
    '%(asctime)s - %(name)s - %(levelname)s - %(message)s')
handler.setFormatter(formatter)
root.addHandler(handler)


def brainFitness(brain: Brain,
                 config: Config,
                 problems: list[ProblemBase]) -> float:
    newBrain: Brain = brain
    for e in range(config.num_steps_pre_epoch):
        logging.debug("\tPre epoch: {}".format(e))
        newBrain = newBrain.update(True)
    tf_prev = 1000000000
    for e in range(config.num_epochs):
        logging.debug("\tEpoch: {}".format(e))
        for _ in range(config.num_steps_during_epoch):
            newBrain = newBrain.update(False)
        tf = 0
        for pIdx in range(len(problems)):
            problem = problems[pIdx]
            ann = newBrain.extractANN(pIdx)
            training_in, expected_out = problem.trainingSet()
            actual_out = ann.forward(training_in)
            fitness = problem.measureFitness(expected_out, actual_out)
            tf = tf + fitness / len(problems)
        logging.debug("\t\ttf: {}".format(tf))
        if tf >= tf_prev:
            logging.debug("\tBailing early, fitness did not improve")
            return tf_prev
        else:
            tf_prev = tf
    return tf_prev


problems = [
    IrisProblem(),
    GlassProblem()
]

config = Config(
    num_inputs=[
        problem.numInputs()
        for problem in problems
    ],
    num_outputs=[
        problem.numOutputs()
        for problem in problems
    ]
)

brain_builder = BrainBuilder(config)
brain_mutator = BrainMutator(config)

lamb = 5

logging.info("Pre Generations")
individuals = []
for _ in range(1+lamb):
    individuals.append(brain_builder.build())

logging.info("\tMeasuring fitnesses")

fitnesses = []
for idx, brain in enumerate(individuals):
    logging.info("\tEvaluating: {}".format(idx))
    fitness = brainFitness(brain, config, problems)
    fitnesses.append(fitness)

# Find the highest:
bestIdx = fitnesses.index(min(fitnesses))
parent = individuals[bestIdx]

for generation in range(500):
    logging.info("Generation: {}".format(generation))
    # Make the offspring:
    offspring = []
    for _ in range(lamb):
        offspring.append(brain_mutator.mutate_brain(parent))
    # Measure the parent fitness and offspring fitness:
    parent_fitness = brainFitness(parent, config, problems)
    logging.debug("\t\tParent fitness: {}".format(parent_fitness))
    offspring_fitnesses = [
        brainFitness(brain, config, problems) for brain in offspring]
    logging.debug("\t\tOffspring fitnesses: {}".format(offspring_fitnesses))

    bestOffspringFitness = min(offspring_fitnesses)
    bestOffspringIdx = offspring_fitnesses.index(bestOffspringFitness)

    if bestOffspringFitness <= parent_fitness:
        parent = offspring[bestOffspringIdx]

    new_parent_fitness = brainFitness(parent, config, problems)
    logging.info("\tFitness: {}".format(new_parent_fitness))
