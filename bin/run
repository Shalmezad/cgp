#!/usr/bin/env python3

import sys
sys.path.append('.')

from dataclasses import dataclass
import random

import numpy as np

from cgp.gene import Gene, GeneBuilder, GeneBuilderConfig
from cgp.gene import GeneMutator, GeneMutatorConfig
from cgp.gene import OpSets

from cgp.problems import IrisProblem

@dataclass
class MeasuredGene:
    fitness: float
    gene: Gene

problem = IrisProblem()

op_set = OpSets.GPTP_II

builder_config = GeneBuilderConfig(problem.numInputs(), 200, problem.numOutputs(), op_set)
builder = GeneBuilder(builder_config)

mutator_config = GeneMutatorConfig(0.08)
mutator = GeneMutator(mutator_config)

mu = 5
lamb = 10
pool = [builder.makeGene() for x in range(mu)]

validation_input, validation_output = problem.validationSet()
train_input, train_output = problem.trainingSet()

for generation in range(5000):
    print("GENERATION: {}".format(generation))

    # Build our full pool:
    children = []
    for x in range(lamb):
        parent = random.choice(pool)
        child = mutator.mutateGene(parent)
        children.append(child)
    pool.extend(children)

    measured_genes = []
    for gene in pool:
        gene_output = gene.evaluate(train_input)
        fitness = problem.measureFitness(train_output, gene_output)
        measured_genes.append(MeasuredGene(fitness, gene))

    measured_genes.sort(key=lambda x: x.fitness)
    best_mu = measured_genes[:mu]
    pool = [x.gene for x in best_mu]

    validation_evaluated = pool[0].evaluate(validation_input)
    validation_idxes = np.argmax(validation_evaluated, axis=1)
    matches = np.count_nonzero(validation_idxes == validation_output)
    print("Accuracy: {}".format(matches / len(validation_output)))
    # print(validation_idxes.shape)
    # validation_fitness = problem.measureFitness(validation_output, validation_evaluated)
    # print("\tValidation fitness: {}".format(validation_fitness))
    print("\t{}".format(parent.toHumanFormula()))